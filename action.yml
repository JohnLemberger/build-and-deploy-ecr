name: Build and Deploy to ECR
description: Builds an image from a dockerfile, and pushes it up to ECR
inputs:
  access_key_id:
    description: AWS Access Key ID
    required: true
  architecture:
    description: Image architecture
    default: ""
    required: false
  build_config:
    description: File used during build (usually in postinstall) to install your app
    required: false
    default: ""
  buildx_load:
    description: Whether to use the --load flag when building
    default: "false"
    required: false
  buildx_push:
    description: Whether to use the --push flag when building
    default: "false"
    required: false
  deploy:
    description: Whether to push the image to ECR after building it
    required: false
    default: "true"
  dockerfile:
    description: Custom Dockerfile name
    required: false
    default: Dockerfile
  ecr_uri:
    description: The URI for the ECR repository
    required: true
  env_file:
    default: ""
    description: File containing environment variables required for app to run and pass healthcheck
    required: false
  github_ssh_key:
    description: SSH Private Key with access to any private repos you need
    required: false
    default: ""
  healthcheck:
    description: healthcheck path, like /healthcheck
    required: false
    default: /healthcheck
  platform:
    # default: linux/amd64
    default: ""
    description: Image platform
    required: false
  port:
    description: Port the server listens on
    required: false
    default: "3000"
  secret_access_key:
    description: AWS Secret Access Key
    required: true

runs:
  using: composite
  steps:
    - name: Versions
      shell: bash
      id: environment
      # yamllint disable rule:line-length
      run: |
        docker version
        if docker buildx &> /dev/null; then
          echo 'buildx is enabled'
          echo '::set-output name=buildx::enabled'
          docker buildx version
        else
          echo 'buildx unavailable'
        fi
        docker info

    # yamllint disable rule:line-length
    - name: Validate inputs
      shell: bash
      run: |
        # Did we even input, bro?
        test -z "${{inputs.ecr_uri}}" && echo '::error::The ecr_ui input is blank. This probably means that your secret is blank or does not exist.' && exit 2
        test -z "${{inputs.access_key_id}}" && echo '::error::The access_key_id input is blank. This probably means that your secret is blank or does not exist.' && exit 2
        test -z "${{inputs.secret_access_key}}" && echo '::error::The secret_access_key input is blank. This probably means that your secret is blank or does not exist.' && exit 2

        # ensure the dockerfile exists and is readable
        if [ -n '${{ inputs.dockerfile }}' ] && [ ! -r '${{ inputs.dockerfile }}' ]; then
          echo '::error::`${{ inputs.dockerfile }} was not found. If your Dockerfile has a custom name, please specify it using the `dockerfile: Dockerfile.prod` param.'
          exit 2
        fi

        # check for buildx flags when buildx is not enabled
        if [ '${{ steps.environment.output.buildx }}' != 'enabled' ]; then
          # can we use build and push together?
          if [ '${{ inputs.buildx_load }}' = 'true' ]; then
            echo '::error::buildx load requested while buildx is not enabled. Please check your configuration and try again.'
            exit 3
          fi

          if [ '${{ inputs.buildx_push }}' = 'true' ]; then
            echo '::error::buildx push requested while buildx is not enabled. Please check your configuration and try again.'
            exit 3
          fi

          if [ -n '${{ inputs.platform }}' ]; then
            echo '::error::platform requested while buildx is not enabled. Please check your configuration and try again.'
            exit 3
          fi
        fi

    - name: Setup environment variables
      id: setup
      shell: bash
      run: |
        branch=$(cut --fields 3 --delimiter '/' <<< '${{ github.ref }}')
        container_base=$(tr '[:upper:]' '[:lower:]' <<< "${{ inputs.ecr_uri }}/github/${{ github.repository }}/$branch")

        if [ -n '${{ inputs.architecture }}' ]; then
          prefix='${{ inputs.architecture }}-'
        else
          prefix=
        fi

        echo CONTAINER_IMAGE_LATEST=$container_base:${prefix}latest >> $GITHUB_ENV
        echo CONTAINER_IMAGE_SHA=$container_base:$prefix${{ github.sha }} >> $GITHUB_ENV

        # Only include the GITHUB_SSH_KEY if it exists
        if [ -n '${{ inputs.github_ssh_key }}' ]; then
          echo ARG_GITHUB_SSH_KEY='--build-arg "GITHUB_SSH_KEY=${{ inputs.github_ssh_key }}"' >> $GITHUB_ENV
        fi
        if grep --quiet GITHUB_SHA './${{ inputs.dockerfile }}'; then
          echo ARG_GITHUB_SHA='--build-arg "GITHUB_SHA=${{github.sha}}"' >> $GITHUB_ENV
        fi

        # Only include the GITHUB_SHA if it is used (supresses a warning)
        if [ -n '${{ inputs.dockerfile }}' ] && [ '${{ inputs.dockerfile }}' != 'Dockerfile' ]; then
          echo CUSTOM_DOCKERFILE='-f ${{ inputs.dockerfile }}' >> $GITHUB_ENV
        fi

        if [ -n '${{ inputs.build_config }}' ]; then
          echo ARG_BUILD_CONFIG='--build-arg "BUILD_CONFIG=${{ inputs.build_config }}"' >> $GITHUB_ENV
        fi

        if [ -n '${{ inputs.env_file }}' ]; then
          echo ENV_FILE='--env-file ${{ inputs.env_file }}' >> $GITHUB_ENV
        fi

        if [ '${{ steps.environment.output.buildx }}' = 'true' ]; then
          if [ -n '${{ inputs.plaform }}' ]; then
            echo PLATFORM='--platform ${{ inputs.plaform }}' >> $GITHUB_ENV
          fi

          echo BUILDX='--push' >> $GITHUB_ENV
        fi

        echo "::set-output name=aws-region::$(cut --fields 4 --delimiter '.' <<< '${{ inputs.ecr_uri }}')"
        echo "::set-output name=base-container-image::$container_base"

    - name: Get ECR login password
      shell: bash
      id: get-login-password
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.secret_access_key }}
      run: |
        login_password="$(aws ecr get-login-password --region '${{ steps.setup.output.aws-region }}')"

        if [ -z "$login_password" ]; then
          echo '::error::Unable to obtain ECR password'
          exit 4
        fi

        echo "::set-output name=password::$login_password"
    - name: Docker login
      shell: bash
      run: >
        docker login
        --username AWS
        --password-stdin
        ${{ inputs.ecr_uri }} <<< '${{ steps.get-login-password.output.password }}'

    - name: Docker build
      shell: bash
      run: >
        docker build
        --tag $CONTAINER_IMAGE_SHA
        --tag $CONTAINER_IMAGE_LATEST
        $CUSTOM_DOCKERFILE
        $ARG_BUILD_CONFIG
        $ARG_GITHUB_SSH_KEY
        $ARG_GITHUB_SHA
        $BUILDX
        $PLATFORM
        .

    - name: Check health
      # if: ${{ inputs.healthcheck != '' }}
      shell: bash
      run: |
        if [ -n '${{ inputs.healthcheck }}' ]; then
          # Healthcheck the built container
          docker run --detach \
            --publish ${{inputs.port}}:${{inputs.port}} \
            $ENV_FILE \
            --env "HEALTHCHECK=${{inputs.healthcheck}}" \
            --env "PORT=${{inputs.port}}" \
            --name test-container $CONTAINER_IMAGE_SHA

          ATTEMPT_COUNT=0
          MAX_ATTEMPTS=5

          HEALTHCHECK="http://localhost:${{inputs.port}}${{inputs.healthcheck}}"

          until $(curl --output /dev/null --silent --head --fail --max-time 5 "${HEALTHCHECK}"); do
            if [ "$((++ATTEMPT_COUNT))" -gt "${MAX_ATTEMPTS}" ];then
              echo "::error::Container did not pass healthcheck at $HEALTHCHECK after $MAX_ATTEMPTS attempts"
              echo "::warning::If your container does not require a healthcheck (most jobs don't), then set healthcheck to a blank string."
              echo "::group::docker logs"
              docker logs test-container
              echo "::endgroup::"
              echo $(docker stop test-container) stopped.
              exit 1
            fi

            sleep 5
            echo "Tested healthcheck ${HEALTHCHECK} : Attempt ${ATTEMPT_COUNT} of ${MAX_ATTEMPTS}"
          done

          echo "Healthcheck passed!"
          echo $(docker stop test-container) stopped.
        else
          echo '::warning::No healthcheck specified'
        fi
    - name: Push to ECR
      # if: ${{ inputs.deploy == 'true' }}
      shell: bash
      run: |
        if [ '${{ inputs.deploy }}' = 'true' ]; then
          docker push ${{ steps.setup.output.base-container-image }} --all-tags
        fi

        # docker manifest create
